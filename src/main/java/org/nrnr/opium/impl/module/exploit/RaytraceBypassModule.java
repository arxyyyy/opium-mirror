package org.nrnr.opium.impl.module.exploit;


import net.minecraft.network.packet.c2s.play.PlayerInteractBlockC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
import org.nrnr.opium.api.config.Config;
import org.nrnr.opium.api.config.setting.BooleanConfig;
import org.nrnr.opium.api.config.setting.EnumConfig;
import org.nrnr.opium.api.config.setting.NumberConfig;
import org.nrnr.opium.api.event.listener.EventListener;
import org.nrnr.opium.api.module.ModuleCategory;
import org.nrnr.opium.api.module.ToggleModule;
import org.nrnr.opium.impl.event.PacketEvent;
import org.nrnr.opium.mixin.accessor.AccessorPlayerMoveC2SPacket;
import org.nrnr.opium.util.math.timer.CacheTimer;
import org.nrnr.opium.util.math.timer.Timer;

public class RaytraceBypassModule extends ToggleModule {
    private final Config<Mode> mode = new EnumConfig<>("Type", "", Mode.Motion, Mode.values());
    private final Config<Boolean> Always = new BooleanConfig("Always", "", true);
    private final Config<Float> Keep = new NumberConfig<>("Keep", "", 0f, 2f, 10.0f);
    private final Config<Integer> Delay = new NumberConfig<>("Delay", "", 0, 250, 1000);
    private final Config<Float> offset = new NumberConfig<>("Offset", "", 0f, 15.0f, 40.0f);
    private final Timer timer = new CacheTimer();
    private float pitch = -91;

    public RaytraceBypassModule() {
        super("RaytraceBypass", "Bypass raytrace", ModuleCategory.EXPLOITS);
    }

    @EventListener
    public void onPacketSend(PacketEvent.Send e) {
        switch (mode.getValue()) {
            case Packet -> {
                if (e.getPacket() instanceof PlayerInteractBlockC2SPacket && timer.passed(Delay.getValue())) {
                    if (mc.player != null && mc.world != null && mc.world.isSpaceEmpty(mc.player.getBoundingBox().stretch((0 + Keep.getValue()), (.0 + offset.getValue()), (0 + Keep.getValue())))) {
                        pitch = (float) -75;
                        timer.reset();
                    }
                }
            }
            case Motion -> {
                if (e.getPacket() instanceof PlayerMoveC2SPacket movePacket && pitch != -91) {
                    if (Always.getValue()) {
                        ((AccessorPlayerMoveC2SPacket) movePacket).hookSetPitch(pitch);
                    }
                    ((AccessorPlayerMoveC2SPacket) movePacket).hookSetPitch(pitch);
                    pitch = -91;
                }
            }
        }
    }

    public enum Mode {
        Packet,
        Motion
    }
}










/*
    private final Timer timer = new CacheTimer(); //Stopwatch for the delay
    Config<Boolean> alwaysConfig = new BooleanConfig("Always", "fef", true);
    Config<Boolean> ignoreNotFound = new BooleanConfig("Ignore Not Found", "w", false);
    Config<Integer> multiplier = new NumberConfig<>("Multipiler", "r", 5, 100, 150);
    Config<Integer> dynamic = new NumberConfig<>("Dynamic multiply", "r", 5, 100, 150);
    Config<Integer> dynamicmin = new NumberConfig<>("MultipilerMIn", "r", 5, 100, 150);
    Config<Integer> dynamicmax = new NumberConfig<>("MultipilerMax", "r", 5, 100, 150);
    Config<Integer> dynamicstep = new NumberConfig<>("MultipilerStep", "r", 1, 5, 20);
    private float pitch;
    private float yaw;
        @EventListener
        public void motion(PlayerMoveEvent event) {
            if (mode.getValue() == me.alpha432.oyvey.features.modules.goyda.Resolver.RotationsMode.Motion && this.pitch != -91.0F) {
                event.yaw = this.yaw;
                event.getY = this.pitch;
                this.pitch = -91.0F;
            }
        }

        @EventListener
        public void onPacketSend(PacketEvent.Inbound event) {
            if (event.getPacket() instanceof CPacketPlayerTryUseItemOnBlock && this.timer.passedMs(250L) && !this.canSee((new Vec3d(((CPacketPlayerTryUseItemOnBlock)event.getPacket()).position)).addVector(0.5, 0.5, 0.5))) {
                float[] rot = MathUtil.calcAngle(RotationManager.mc.player.getPositionEyes(mc.getRenderPartialTicks()), (new Vec3d(((CPacketPlayerTryUseItemOnBlock)event.getPacket()).position)).addVector(0.5, 0.5, 0.5));
                this.timer.reset();
                this.yaw = rot[0];
                this.pitch = -90.0F;
                if ((Boolean)Gol.instance.enabled.getValue()) {
                    System.out.println("doing byps");
                }

                if (mc.player.func_184614_ca().getItem() instanceof ItemBlock) {
                    Managers.NETWORK.sendPacket(new PlayerInteractBlockC2SPacket(this.yaw, this.pitch, mc.player.onGround));
                } else if (this.mode.getValue() == me.alpha432.oyvey.features.modules.goyda.Resolver.RotationsMode.Packet) {
                    mc.getConnection().sendPacket(new CPacketPlayer.Rotation(this.yaw, this.pitch, mc.player.onGround));
                }

                this.timer.reset();
            }

        }

    private boolean canSee(Vec3d pos) {
        if (alwaysConfig.getValue())
            return false;
        return mc.world.raycast(new RaycastContext(mc.player.getEyePos(), pos, RaycastContext.ShapeType.COLLIDER, RaycastContext.FluidHandling.NONE, mc.player)).getType() == net.minecraft.util.hit.HitResult.Type.MISS;

        public float[] getRotationForBypass(float limit) {
            float[] rotation = null;
            float best = Float.MAX_VALUE;

            for(float yaw = limit - 5.0F; yaw <= limit + 5.0F; yaw = (float)((double)yaw + 0.5)) {
                for(float pitch = -90.0F; pitch <= -40.0F; pitch = (float)((double)pitch + 0.5)) {
                    float difference = Math.abs(limit - yaw);
                    if ((rotation == null || difference < best) && this.isRotationGoodForRaytrace(yaw, pitch)) {
                        best = difference;
                        rotation = new float[]{yaw, pitch};
                    }
                }
            }

            return rotation;
        }

        public boolean isRotationGoodForRaytrace(float yaw, float pitch) {
            Vec3d eyes = new Vec3d(mc.player.posX, mc.player.posY + (double)mc.player.eyeHeight, mc.player.posZ);
            Vec3d look = this.getVectorForRotation(pitch, yaw);
            if ((Boolean)this.dynamic.getValue() && (Integer)this.dynamicMin.getValue() < (Integer)this.dynamicMax.getValue()) {
                for(int j = (Integer)this.dynamicMin.getValue(); j < (Integer)this.dynamicMax.getValue(); j += (Integer)this.dynamicStep.getValue()) {
                    j = Math.min((Integer)this.dynamicMax.getValue(), j);
                    look = eyes.addVector(look.x * (double)j, look.y * (double)j, look.z * (double)j);
                    if (mc.world.rayTraceBlocks(eyes, look, false, true, false) == null) {
                        return true;
                    }
                }

                return false;
            } else {
                look = eyes.addVector(look.x * (double)(Integer)this.multiplier.getValue(), look.y * (double)(Integer)this.multiplier.getValue(), look.z * (double)(Integer)this.multiplier.getValue());
                return mc.world.rayTraceBlocks(eyes, look, false, true, false) == null || (Boolean)this.ignoreNotFound.getValue();
            }
        }

        public Vec3d getVectorForRotation(float pitch, float yaw) {
            if (yaw > 180.0F) {
                yaw -= 360.0F;
            }

            if (yaw < 180.0F) {
                yaw += 360.0F;
            }

            float f = MathHelper.cos(-yaw * 0.017453292F - 3.1415927F);
            float f1 = MathHelper.sin(-yaw * 0.017453292F - 3.1415927F);
            float f2 = -MathHelper.cos(-pitch * 0.017453292F);
            float f3 = MathHelper.sin(-pitch * 0.017453292F);
            return new Vec3d((double)(f1 * f2), (double)f3, (double)(f * f2));
        }
    }
    public enum mode {
        Motion,
        Packet
    }
}
 */